**把6个互不相等的正整数a、b、c、d、e、f分成两组，若这两个数组具有以下两个相等特性:  a+b+c=d+e+f=s 且 a^2+b^2+c^2=d^2+e^2+f^2=s2，人们把这类数组(a,b,c)与(d,e,f)称为神秘3元数组。设计程序求出给定s的所有神秘3元数组（约定a<b<c, d<e<f, a<d）。例如，(1,5,6)与(2,3,7)就是s=12的神秘3元数组：1+5+6=2+3+7=12；1^2+5^2+6^2=2^2+3^2+7^2=62。**

```c
#include "stdio.h"

int main(void){
    int a,b,c,d,e,f,s;
    scanf("%d",&s);
    for(a = 1;a<=s-2*a-3;a++){    //a+1 a+2 a+3
        for(b = a+1;b<=s-2*a-1;b++){
            for(c = b+1;c<=s-a-b;c++){
                c = s-a-b;
//                printf("%d %d %d\n",a,b,c);
                for(d = a+1;d<=s-2*a-5;d++){
                    for(e=d+1;e<=s-2*d-2;e++){
                        for(f=e+1;f<=s-e-d;f++){
                            f = s - d-e;
                            if((a*a+b*b+c*c)==(d*d+e*e+f*f)) printf("(%d,%d,%d):(%d,%d,%d)\n",a,b,c,d,e,f);
                        }
                            
                    }
                }
            }
            
        }
    }
    return 0;
}


```


**给你2n张牌，编号为1,2,3,...,n,n+1,...,2n，这也是最初的牌的顺序。一次洗牌是把序列变为 n+1,  1,  n+2,  2,  ..,2n,n。可以证明，对于任意正整数n，都可以在经过m次这样的洗牌后，这幅牌重新回到初始的顺序。编程对于2n(n从键盘输入)张牌进行洗牌，求出重新得到初始顺序的洗牌次数m的值。**

```c
#include "stdio.h"

int main(void){
    int n,sum=1,i=0,j=1,temp;
    /*  1 2 3 4   3 1 4 2
     b[1] =a[n+1] b[2] = a[1] b[3] = a[n+2]
    */
    int a[1000],b[1000];
    scanf("%d",&n);
    temp = n;
    for(i = 1;i<=2*n;i++) a[i] = i; //1 2
    for(i = 1;i<=2*n;i++){
        if(i%2!=0) b[i] = a[++temp];  //2 1
        else b[i] = a[j++];
    }
//    printf("%d\n",b[1]);
    while(1){
        temp = n;
        j = 1;
        for(i = 1;i<=2*n;i++){
            if(i%2!=0) a[i] = b[++temp];  //1 n+1 2 1 3 n+2
            else a[i] = b[j++];  // 1 2
        }
        sum++;
        temp = n;
        j = 1;
//        printf("经%d次洗牌回到初始状态\n",a[1]);
        if(a[1] ==1) {
            printf("经%d次洗牌回到初始状态\n",sum);
            break;
        }
        for(i = 1;i<=2*n;i++){
            if(i%2!=0) b[i] = a[++temp];  //1 n+1 2 1 3 n+2
            else b[i] = a[j++];
        }
        sum++;
        if(b[1] ==1) {
            printf("经%d次洗牌回到初始状态\n",sum);
            break;
        }
    }
    return 0;
}


```

**判断密码强度等级**

```c
#include "stdio.h"
#include "string.h"
int main(void){
    char pw[20],p1=0,p2=0,p3=0,p4=0; //p1小写字母p2大写字母p3数字p4其他字符
    int n,i;
    scanf("%d",&n);
    getchar();
    while(n>0){
        p1 = p2 = p3 = p4 = 0;
        n--;
        gets(pw);
        
        if(strlen(pw)<6) {
            printf("Not Safe\n");
            continue;
        }
        for(i = 0;i<strlen(pw);i++){
            if(pw[i]>='a'&&pw[i]<='z') {
                p1++;
                continue;
            }
            if(pw[i]>='A'&&pw[i]<='Z') {
                p2++;
                continue;
            }
            if(pw[i]>='0'&&pw[i]<='9') {
                p3++;
                continue;
            }
            else p4++;
        }
        if(p1>0) p1 = 1;
        if(p2>0) p2 = 1;
        if(p3>0) p3 = 1;
        if(p4>0) p4 = 1;
//        printf("%d %d %d %d\n",p1,p2,p3,p4);
        if((p1+p2+p3+p4)==1) printf("Not Safe\n");
        if((p1+p2+p3+p4)==2) printf("Medium Safe\n");
        if((p1+p2+p3+p4)>=3) printf("Safe\n");
        
    }
    return 0;
}


```

**孪生素数**

```c
#include "stdio.h"

int ifprime(int x);
int main(void){
    int m,n,i;
    scanf("%d %d",&m,&n);
    for(i = m;i<=n;i++){
        if(ifprime(i)&&ifprime(i+2)&&(i+2)<=n){
            printf("%d %d",i,i+2);
            printf("\n");
            
        }
    }
    
    return 0;
}

int ifprime(int x){
    int i;
    if(x==1) return 0;
    for(i = 2;i<=x/2;i++){
        if(x%i==0) return 0;
    }
    return 1;
}

```
**字符串逆序**

```c
#include "stdio.h"
#include "string.h"
int main(){
    int i=0;   //abcdf
    char s[100],temp;
    gets(s);
    for(i = 0;i<strlen(s)/2;i++){
        temp = s[i];
        s[i] = s[strlen(s)-i-1];
        s[strlen(s)-i-1] = temp;
    }
    puts(s);
    return 0;
}

```

**找出元音**

```c
#include "stdio.h"
#include "string.h"
int main(){
    char s1[1000],s2[100];
    int i,j=0;
    gets(s1);
    for(i = 0;s1[i]!='\0';i++){
        if(s1[i]=='a'||s1[i]=='e'||s1[i]=='i'||s1[i]=='o'||s1[i] =='u'){
            s2[j] = s1[i];
            j++;
        }
    }
    s2[j] = '\0';
    puts(s2);
    return 0;
}

```


**寻找最长单词**

```c
#include "stdio.h"
#include "string.h"
int main(){
    char str[1000],s[100],temp[100];
    int length=0,i,j = 0;
    gets(str);
    for(i = 0;i<=strlen(str);i++){
        if(str[i] == ' '||str[i]=='\0') {
            s[j]='\0';
            if(length==0){
                length = (int)strlen(s);
                strcpy(temp, s);
                j = 0;
                continue;
            }
            if(strlen(s)>length) strcpy(temp, s);
            j = 0;
            continue;
        }
        s[j] = str[i];
        j++;
        
    }
    puts(temp);
    return 0;
}

```

**约瑟夫问题**

```c
#include <stdio.h>
 
int Josephus(int n, int m) {
    int i, x = 0;
    for (i = 1; i <= n; ++i) {
        x = (x + m) % i;
    }
    return x;
}
 
int main() {
 
    int n, m, s;
 
    scanf("%d%d%d", &n, &s, &m);
 
    printf("%d\n", Josephus(n, m) + s);
    return 0;
}
```


**绝对素数问题，该数以及该数的逆序都为素数**

```c
#include<stdio.h>
#include<string.h>
int prime(int x);
int reverse(int x);

int main(){
    int m,n,num,sum=0;
    scanf("%d %d",&m,&n);
    for(num = m;num<=n;num++){
        if(prime(num)&&prime(reverse(num))) {
            printf("%5d",num);
            sum++;
            if(sum%10==0) printf("\n");
        }
        
    }
    printf("\n");

    return 0;
}

int prime(int x){
    int i;
    for(i = 2;i<=x/2;i++){
        if(x%i == 0)  return 0;
    }
    return 1;
}

int reverse(int x){    //123
    int a;
    a = x%10;
    while(x>=10){
        x/=10;
        a= a*10+x%10;
    }
    return a;
}
```

**矩阵操作，将每一位除以该行的对角线元素**

```c
#include<stdio.h>
#include<string.h>
int main(){
    int i,j,n,m;
    float a[6][6];
    scanf("%d",&n);
    for(i = 0;i<n;i++){
        for(j = 0;j<n;j++){
            scanf("%f",&a[i][j]);
        }
    }
    for(i = 0;i<n;i++){
        m=a[i][i];
        for(j = 0;j<n;j++){
            a[i][j] = a[i][j]/m;
        }
    }
    for(i = 0;i<n;i++){
        for(j = 0;j<n;j++){
            printf("%.2f",a[i][j]);
            if(j!=(n-1)) printf(" ");
        }
        printf("\n");
    }
    return 0;
}

```

**链表解决约瑟夫问题**

```c
#include <stdio.h>
#include <stdlib.h>

/*构建结构体*/
typedef struct Node{
    int Num;
    struct Node *next;
}JoseNode, *PNode, *HNode;

/**********初始化循环单链表*********/
int JoseInit(HNode *h)
{
    if (!h)
    {
        printf("初始化链表错误！\n");
        return 0;
    }
    (*h)->next = (*h);//循环单链表
    return 1;
    
}

/*************单链表插入操作**********/
int JoseInsert(JoseNode *h, int pos, int x)
{
    PNode p=h,q;
    int i=1;
    if (pos == 1)/*尾插法*/
    {
        p->Num = x;
        p->next = p;
        return 1;
    }
    while(i<pos-1)
    {
        p=p->next;
        i++;
    }
    q=(PNode)malloc(sizeof(JoseNode));
    q->Num=x;
    q->next=p->next;
    p->next=q;
    return 1;
}

/*遍历*/
void TraverseList(HNode h, int M)
{
    int i = 0;
    PNode p = h;
    printf("参与的人的编号为：\n");
    while (i<M)
    {
        printf("%d\t", p->Num);
        p = p->next;
        i++;
    }
    printf("\n");
}
/**************出局函数****************/

int JoseDelete(HNode h, int M, int k)
{    int i;
    PNode p=h,q;
    while(M>1)
    {
        for(i=1;i<k-1;i++)
        {
            p=p->next;
        }
        
        q=p->next;
        p->next=q->next;
        printf("出局的人为：%d号\n",q->Num);
        free(q);
        
        p=p->next;
        M--;
    }
    printf("***************获胜者为：%d号***************",p->Num);
    return 1;
}


/***************************************/
int main()
{
    int i;//计数器
    int N;//参与的人数
    int k;//报数密码
    printf("请输入参与人数：");
    scanf("%d",&N);
    printf("请输入出局密码：");
    scanf("%d",&k);
    
    /**************得到头结点****************/
    HNode h = ((HNode)malloc(sizeof(JoseNode)));
    
    /***************初始化单链表************/
    JoseInit(&h);
    
    /******将编号插入到循环单链表中******/
    for (i = 1; i <=N; i++)
    {
        JoseInsert(h, i, i);
    }
    /**************遍历单链表***************/
    TraverseList(h,N);
    
    /***************出局函数************/
    if(k > 1)
        JoseDelete(h, N, k);
    else
    {
        for(i = 1; i < N; i++)
            printf("出局的人为：%d号\n",i);
        printf("***************获胜者为：%d号***************",N);
    }
    
    printf("\n");
    printf("\n");
    return 0;
}

```

**给一组数据排序，负数在左，正数在右**

```c
#include "stdio.h"
#include "string.h"
int main(){
    int a[100],b[100],i,j,n;
    while(scanf("%d",&n)!=EOF){
        j = 0;
        for(i = 0;i<n;i++){
            scanf("%d",&a[i]);
        }
        for(i = 0;i<n;i++){
            if(a[i]<=0) {
                printf("%d ",a[i]);
            }
            else{
                b[j] = a[i];
                j++;
            }
        }
        if(j==0) printf(" ");
        for(i = 0;i<j;i++){
            printf("%d",b[i]);
            if(i!=j-1) printf(" ");
        }
        printf("\n");
    }
    return 0;
}

#include<stdio.h>
#include<string.h>
int main(){
    int a[100],n,i,j,m,temp;
    scanf("%d",&n);
    for(i = 0;i<n;i++){
        scanf("%d",&a[i]);
    }
    for(i = 0;i<n;i++){  //-1 -2 2 4 -3     -1
        if(a[i]<0){        // 3  3
            if(i==0) continue;
            temp = a[i];
            for(m = 0;m<i;m++){
                if(a[m]>0){
                    break;
                }
            }
            if(m ==i) continue;
            for(j=i;j>m;j--){
                a[j] = a[j-1];
            }
            a[m] = temp;
        }
    }
    for(i = 0;i<n;i++){
        printf("%d",a[i]);
        if(i!=n-1) printf(" ");
    }
    printf("\n");
    return 0;
}

```


**递归求组合函数**

```c
#include<stdio.h>
#include<string.h>
int zh(int m,int n);
int main(){
    int m,n;
    scanf("%d %d",&m,&n);
    printf("%d\n",zh(m,n));
    return 0;
}

int zh(int m,int n){
    int sum=0;
    if(m<n) return 0;
    if(n == 0) {
        sum = 1;
        return sum;
    }
    if(n == 1) {
        sum +=m;
        return sum;
    }
    else{
        sum +=zh(m-1, n-1)+zh(m-1,n);
    }
    return sum;
}

```


**输入一个长度不超过 100 的字符串，删除串中的重复字符。**

```c
#include<stdio.h>
#include<string.h>
int main() {
    char str[100],str2[100];
    int i,j=0,m,flag;
    gets(str);
    for(i = 0;i<strlen(str);i++){
        if(j==0) {
            str2[j] = str[i];
            j++;
        }
        else{
            flag=1;
            for(m=0;m<=j;m++){
                if(str[i]==str2[m]) {
                    flag=0;
                    break;
                }
            }
            if(flag) {
                str2[j] = str[i];
                j++;
            }
        }
    }
    str2[j]='\0';
    puts(str2);
    return 0;
}
```







**输入数据有多组。每组输入的第一行是一个整数 n（0 < n <= 1000），表示接下来会有 n 个文件名。接下来的 n行为文件名，每个文件名占一行。文件名最多 16 个字符，并且中间不包含空格。如果 n 等于 0，则程序结束。输出以字典顺序输出每一组数据中的病毒文件名。每个文件名输出一行。**

```c
#include<stdio.h>
#include<string.h>
int isVirus(char *s)
{
    int len;
    len=(int)strlen(s);
    if(len>4 && strcmp(s+len-4,".exe") == 0) {return 1;}
    return 0;
}
int main()
{
    int n,i,j,k,l,m,flag;
    char s[1000][17],str[1000][17],temp[17];
    char *p,*q;
    scanf("%d",&n);
    while(n!=0)
    {
        j=0;
        for(i=0;i<n;i++) {scanf("%s",s[i]);}
        for(i=0;i<n;i++)
        {
            if(isVirus(s[i]))
            {
                for(k=0;k<n;k++)
                {
                    if(k==i) {continue;}
                    else
                    {
                        if((strlen(s[i])-strlen(s[k]))==4)
                        {
                            p=s[k];q=s[i];
                            flag=1;
                            while(*p!='\0' && *q!='\0')
                            {
                                if(*p==*q) {p++;q++;}
                                else {flag=0;break;}
                            }
                            if(flag) {strcpy(str[j],s[i]);j++;}
                        }
                    }
                }
            }
        }
        for(i=0;i<j;i++)
        {
            for(l=i+1;l<j;l++)
            {
                if(strcmp(str[i],str[l])>0)
                {
                    strcpy(temp,str[l]);
                    strcpy(str[l],str[i]);
                    strcpy(str[i],temp);
                }
            }
        }
        for(i=0;i<j;i++) {puts(str[i]);}
        scanf("%d",&n);
    }
    return 0;
}




```

```c
#include<stdio.h>
#include<string.h>
int main()
{
    char s1[100], s2[100],s3[50];
    int i, j, k1, k2, max=0, w1[100],w2[100],f;
    while((gets(s1)!= NULL)&&(gets(s2)!=NULL)){
        i = j = k1 = k2 = max=f=0;
        s3[0] = '\0';
        for(i=0, k1=0, f=1 ; s1[i]!='\0'; i++)
        {
            if(s1[i]==' ')  { s1[i]='\0'; f=1;}
            if(f==1&&s1[i]!='\0') { w1[k1]=i;k1++; f=0;}
        }
        for(i=0, k2=0, f=1;  s2[i]!='\0'; i++)
        {
            if(s2[i]==' ')   { s2[i]='\0';  f=1;}
            if(f==1&&s2[i]!='\0') {w2[k2]=i; k2++; f=0;}
        }
        for(i=0; i<k1; i++)
            for(j=0; j<k2; j++)
                if(strcmp(s1+w1[i],s2+w2[j])==0)
                    if(strlen(s1+w1[i])>=max)
                    {max = (int)strlen(s1+w1[i]); strcpy(s3, s1+w1[i]);}
        if(max!=0) puts(s3);
        else printf("No common word!\n");
    }
    

}
```
**寻找最长公共单词**

```c
错误代码
#include "stdio.h"
#include "string.h"

int main(){
    char str1[100], str2[100],s1[20],length=0,s2[20],result[20];
    int i,j=0,k=0;
    fgets(str1, 100, stdin);
    fgets(str2, 100, stdin);
    for(i = 0;i<strlen(str1)-1;i++){
        if(str1[i]!='?'&&str1[i]!=','&&str1[i]!='.') {
            s1[j] = str1[i];
            j++;
        }
        else{
            s1[j]='\0';
            puts(s1);
            for(j = 0;j<strlen(str2)-1;j++){
                if(!(str2[i]=='?'||str2[i]==','||str2[i]=='.')) {
                    s2[k] = str2[j];
                    k++;
                }
                else{
                    s2[k]='\0';
                    //                    puts(str2);
                    if(strcmp(s1, s2)==0&&strlen(s1)>length) {
                        length=strlen(s1);
                        strcpy(result, s2);
                    }
                    k=0;
                }
            }
            j=0;
            
        }
    }
    if(length!=0) printf("%s\n",result);
    else printf("No common word!\n");
    return 0;
}
```










```c
#include "stdio.h"
#include "string.h"
int main(){
    char str1[50][20];
    char str2[50][20];
    int stus, comes,i,j=0;
    while(scanf("%d %d",&stus,&comes)!=EOF){
        j=0;
        for(i=0;i<stus;i++){
            scanf("%s",str1[i]);
        }
        for(i = 0;i<comes;i++){
            scanf("%s",str2[i]);
        }
        for(i=0;i<stus;i++){
            if(strcmp(str1[i], str2[j])==0){
                printf("Yes\n");
                j++;
            }
            else{
                printf("No\n");
            }
        }
    }
    return 0;
}
```








```c
#include<stdio.h>
int main(){
    int a,b,c,d,e,f;//a-f对应1*1到6*6的箱子
    int u[]={0,5,3,1};//装3*3类箱子不满时可以装2*2类箱子的4种情形
    while(scanf("%d%d%d%d%d%d", &a, &b, &c, &d, &e, &f)!=EOF){
        if(a==0 && b==0 && c==0 && d==0 && e==0 && f==0)break;
        int x,y;//x代表用于装2*2类箱子的空位，y代表用于装1类箱子的空位
        int N=0;//总共所需要的包装的数量
        N=f+e+d+(c+3)/4;//统计3*3-6*6类箱子所需要的包装数
        //上式中（c+3)/4的作用：当c/4的余数不论为几时，都需要再增加一个箱子，即只能多不能少；
        x=5*d+u[c%4];//统计4类箱子和3类箱子留给2类箱子的空位
        if(b >x){
            N+=(b-x+8)/9;//统计算上遗留空位2*2类箱子所占的包装数量
        }
        y=N*36-f*36-e*25-d*16-c*9-b*4;//遗留给1*1类箱子的空位
        if(a >y){
            N+=(a-y+35)/36;
        }
        printf("%d\n", N);
    }
    return 0;
}
#include "stdio.h"
int main(void){
    char str[100], ch;
    int i=0;
    scanf("%s",str);
    getchar();
    scanf("%c",&ch);
    while(str[i] != '\0'){
        if(str[i] == ch) {
            i++;
            continue;
        }
        printf("%c",str[i]);
        i++;
    }
    printf("\n");
    return 0;
}
```

```c
#include<stdio.h>
#include<string.h>
int main()
{
    char s1[100], s2[100],s3[50];
    int i, j, k1, k2, max=0, w1[100],w2[100],f;
    gets(s1);  gets(s2);
    for(i=0, k1=0, f=1 ; s1[i]!='\0'; i++)
    {
        if(s1[i]==' ')  { s1[i]='\0'; f=1;}
        if(f==1&&s1[i]!='\0') { w1[k1]=i;k1++; f=0;}
    }
    for(i=0, k2=0, f=1;  s2[i]!='\0'; i++)
    {
        if(s2[i]==' ')   { s2[i]='\0';  f=1;}
        if(f==1&&s2[i]!='\0') {w2[k2]=i; k2++; f=0;}
    }
    for(i=0; i<k1; i++)
        for(j=0; j<k2; j++)
            if(strcmp(s1+w1[i],s2+w2[j])==0)
                if(strlen(s1+w1[i])>=max)
                {max = (int)strlen(s1+w1[i]); strcpy(s3, s1+w1[i]);}
    puts(s3);
    return 0;
}
```


