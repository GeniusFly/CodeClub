**彩球下落游戏.每组数据第一行为N（1<=N<=12），代表障碍物有N行。第二行N+1个整数，每个数不大于100，用空格分隔，代表最底层每个容器的分数值。第三行为一个整数，代表需要计算得到的分数**

:grinning:

```c
#include "stdio.h"
int main(){
    int n,a[13][13],i,j,grades[14];
    double result;
    while(scanf("%d",&n)!=EOF){
        for(i = 0;i<=n;i++){
            scanf("%d",&grades[i]);
        }
        
    }
    return 0;
}

```

**判断一个十进制数的二~十进制形式是不是回文数**

```c
#include "stdio.h"
int trans(int x,int w);
int reverse(int x);
int main(){
    int num,flag,i,temp;
    
    while(scanf("%d",&num)!=EOF){
        flag=0;
        for(i=2;i<=9;i++){
            temp = trans(num,i);
            //printf("%d  ",temp);
            if(temp == reverse(temp)) flag=1;
        }
        if(reverse(num)==num) flag=1;
        if(flag==1) printf("Yes\n");
        else printf("No\n");
    }
    return 0;
}

int trans(int num,int w){
    int i,j,sum = 1;
    int a[100];
    i = 0;
    while (num>0) {   //5 101  8
        a[i] = num%w;  //
        i++;
        num=num/w;
    }
    sum = a[i-1];   //j=
    for(j = i-2;j>=0;j--){
        sum=sum*10+a[j];
    }
    return sum;
}

int reverse(int x){
    int sum;
    sum=x%10;
    while (x>=10) {
        x/=10;
        sum=sum*10+x%10;
    }
    return sum;
}

```

**把数字转换成汉字的数字,如 101 一百零一,10 十**

```c
#include "stdio.h"
#include "string.h"
void format(int i, int num,int flag,int front);
int reverse(int x,char a[]);
int main(){
    int num,j,temp,flag;
    char a[100];
    while (scanf("%d",&num) !=EOF) {    //10
        j = reverse(num, a);
        //printf("%c\n",a[1]);
        flag=1;
        while(j>=0){   //1001
            if(j==2) {
                if(a[j]-48==0&&a[j-1]-48==0&&a[j-2]-48==0){
                    break;
                }
            }
            if(j==1){
                if(a[j]-48==0&&a[j-1]-48==0){
                    
                    break;
                }
            }
            temp = a[j]-48;
            if(flag==1) format(j+1, temp,flag,1);
            if(flag==0) format(j+1,temp,flag,a[j+1]-48);
            j--;
            flag = 0;
        }
        printf("\n");
        
    }
    return 0;
}

int reverse(int x,char a[]){
    int i = 0;
    a[i] = x%10+48;
    while(x>=10){
        x/=10;
        a[++i] = x%10+48;
    }
    return i;
}


void format(int i,int num,int flag,int front){
    char nu[100]="";
    if(front==0&&num==0){
        return;
    }
    switch (num) {
        case 0:
            strcpy(nu, "零\0");
            break;
        case 1:
            strcpy(nu, "一\0");
            break;
        case 2:
            strcpy(nu, "二\0");
            break;
        case 3:
            strcpy(nu, "三\0");
            break;
        case 4:
            strcpy(nu, "四\0");
            break;
        case 5:
            strcpy(nu, "五\0");
            break;
        case 6:
            strcpy(nu, "六\0");
            break;
        case 7:
            strcpy(nu, "七\0");
            break;
        case 8:
            strcpy(nu, "八\0");
            break;
        case 9:
            strcpy(nu, "九\0");
            break;
        default:
            strcpy(nu, "\0");
            break;
    }
    switch (i) {
        case 1:
            if(num!=0) printf("%s",nu);
            if(num==0&&flag==1) printf("零");
            break;
        case 2:
            if(num!=0){
                if(flag==1&&num==1) printf("十");
                else printf("%s十",nu);
            }
            if(num ==0) printf("零");
            break;
        case 3:
            if(num==0) printf("零");
            else printf("%s百",nu);
            break;
        case 4:
            if(num==0) printf("零");
            printf("%s千",nu);
            break;
        case 5:
            if(num==0) printf("零");
            printf("%s万",nu);
            break;
        default:
            break;
    }
    
}

```

**十进制和二进制相互转换**

```c
#include "stdio.h"
#include "string.h"
#include "math.h"
int main(){
    char f;
    int i=0,j,num,sum=0,a[100];
    while(scanf("%c",&f)!=EOF){
        scanf("%d",&num);
        if(f=='B'){
            i = 0;
            sum = 0;
            while(num>0){
                sum+=num%10*(pow(2,i));
                i++;
                num/=10;
            }
            printf("%d\n",sum);
        }
        if(f=='D'){
            i = 0;
            while (num>0) {
                a[i] = num%2;
                i++;
                num/=2;
            }
            sum = a[i-1];
            for(j = i-2;j>=0;j--){
                sum=sum*10+a[j];
            }
            printf("%08d\n",sum);
        }
    }
    return 0;
}

```


**把一个字符串中的we全部替换为you**

```c
#include "stdio.h"
#include "string.h"
int main(){
    char str[1000],str2[1000];
    int i,j;
    while (gets(str)) {
        j=0;
        for(i=0;i<strlen(str);i++){
            if(str[i]=='w'&&str[i+1]=='e'){
                strcat(str2, "you");
                i++;
                j=j+3;
            }
            else {
                str2[j] = str[i];
                j++;
            }
        }
        str2[j] = '\0';
        puts(str2);
    }
    return 0;
}

```

**在公司与租住的房子之间有M-2个充电站，他的电动车可以骑1站或2站的路程，设第一站是租住的房子，第M站是公司，而且一开始的电池是充满的，那么他共有多少中方式可以去公司？**

```c
#include "stdio.h"
int ways(int m);
int main(){
    int m;
    while(scanf("%d",&m)!=EOF){
         printf("%d\n",ways(m));
    }
    return 0;
}

int ways(int m){
    if(m==1) return 0;
    else if(m==2) return 1;
    else if(m==3) return 2;
    else if(m==4) return 3;
    else if(m==5) return 5;
    else if(m==6) return 8;
    else if(m==7) return 13;
    else if(m==8) return 21;
    else if(m==9) return 34;
    else if(m==10) return 55;
    //以上这些事为了减少运行时间!!!!!
    else{
        return ways(m-1)+ways(m-2);
    }
}

```

**利用指针字符串复制**

```c
#include "stdio.h"
#include "string.h"
int main(){
    char str[100],cpy[100];
    char *p;
    int i=0,n;
    gets(str);
    scanf("%d",&n);
    if(n>strlen(str)) printf("Data error!\n");
    else{
        p = &str[n];
        while(*p !='\0'){
            cpy[i] = *p;
            i++;
            p++;
        }
        puts(cpy);
    }

    return 0;
}

```

**首先输入一个数字，表示这个数列有几个数字组成，然后回车依次输入这个数列每个数字(0-9)，输入一个数字，回车一下。输出A中长度最大的所有等值数列段的始末位置，以The longest equal number list is from打头如果没有等值数列段，则输出 No equal number list.说明：始末位置是指数组下标，即0表示第一个元素。 如果有多个同等长度的等值数列，只输出第一个等值数列的起始位置。 当在一个LIST中出现两个等长的连续串的时候，我们的答案应该是第一个等长串。**

```c
#include "stdio.h"
int main(){
    int a[50],i,length=0,n,temp,start=0 ,end=0,start1,end1;
    scanf("%d",&n);
    for(i = 0;i<n;i++){
        scanf("%d",&a[i]);
    }
    for(i = 0;i<n-1;i++){
        temp = 0;
        start1 = i;
        while(a[i+1]==a[i]){
            temp++;
            i++;
        }
        end1=i;
        if(length<temp) {
            length = temp;
            start = start1;
            end = end1;
        }
    }
    if(length == 0) printf("No equal number list.\n");
    else printf("The longest equal number list is from %d to %d.\n",start,end);
    return 0;
}

```


**四种邮票的面值。输出用这四种面值组成的邮资最大的从1开始的一个连续的区间。说明：如结果为10，则表明使用4张邮票可组合出1、2、3、4、5、6、7、8、9、10这些邮资。**

```c
#include<stdio.h>
int main(){
    int i, j, k, p, a1, a2, a3, a4, m=1, flag=0;
    scanf("%d%d%d%d",&a1,&a2,&a3,&a4);
A: for( i = 0 ; i <= 5 ; i++ ){
    for( j = 0 ; j <= 5 - i ; j++ ){
        for( k = 0 ; k <= 5 - i - j ; k++ ){
            for( p = 0 ; p <= 5 - i - j - k ; p++ ){
                flag = 1 ;
                if( a1 * p + a2 * k + a3 * j + a4 * i == m ){
                    flag = 0;
                    m++;
                    goto A;
                }
            }
        }
    }
}
    printf("%d.\n",m-1);
    return 0;
}

```



**把6个互不相等的正整数a、b、c、d、e、f分成两组，若这两个数组具有以下两个相等特性:  a+b+c=d+e+f=s 且 a^2+b^2+c^2=d^2+e^2+f^2=s2，人们把这类数组(a,b,c)与(d,e,f)称为神秘3元数组。设计程序求出给定s的所有神秘3元数组（约定a<b<c, d<e<f, a<d）。例如，(1,5,6)与(2,3,7)就是s=12的神秘3元数组：1+5+6=2+3+7=12；1^2+5^2+6^2=2^2+3^2+7^2=62。**

```c
#include "stdio.h"

int main(void){
    int a,b,c,d,e,f,s;
    scanf("%d",&s);
    for(a = 1;a<=s-2*a-3;a++){    //a+1 a+2 a+3
        for(b = a+1;b<=s-2*a-1;b++){
            for(c = b+1;c<=s-a-b;c++){
                c = s-a-b;
//                printf("%d %d %d\n",a,b,c);
                for(d = a+1;d<=s-2*a-5;d++){
                    for(e=d+1;e<=s-2*d-2;e++){
                        for(f=e+1;f<=s-e-d;f++){
                            f = s - d-e;
                            if((a*a+b*b+c*c)==(d*d+e*e+f*f)) printf("(%d,%d,%d):(%d,%d,%d)\n",a,b,c,d,e,f);
                        }
                            
                    }
                }
            }
            M
        }
    }
    return 0;
}


```


**给你2n张牌，编号为1,2,3,...,n,n+1,...,2n，这也是最初的牌的顺序。一次洗牌是把序列变为 n+1,  1,  n+2,  2,  ..,2n,n。可以证明，对于任意正整数n，都可以在经过m次这样的洗牌后，这幅牌重新回到初始的顺序。编程对于2n(n从键盘输入)张牌进行洗牌，求出重新得到初始顺序的洗牌次数m的值。**

```c
#include "stdio.h"

int main(void){
    int n,sum=1,i=0,j=1,temp;
    /*  1 2 3 4   3 1 4 2
     b[1] =a[n+1] b[2] = a[1] b[3] = a[n+2]
    */
    int a[1000],b[1000];
    scanf("%d",&n);
    temp = n;
    for(i = 1;i<=2*n;i++) a[i] = i; //1 2
    for(i = 1;i<=2*n;i++){
        if(i%2!=0) b[i] = a[++temp];  //2 1
        else b[i] = a[j++];
    }
//    printf("%d\n",b[1]);
    while(1){
        temp = n;
        j = 1;
        for(i = 1;i<=2*n;i++){
            if(i%2!=0) a[i] = b[++temp];  //1 n+1 2 1 3 n+2
            else a[i] = b[j++];  // 1 2
        }
        sum++;
        temp = n;
        j = 1;
//        printf("经%d次洗牌回到初始状态\n",a[1]);
        if(a[1] ==1) {
            printf("经%d次洗牌回到初始状态\n",sum);
            break;
        }
        for(i = 1;i<=2*n;i++){
            if(i%2!=0) b[i] = a[++temp];  //1 n+1 2 1 3 n+2
            else b[i] = a[j++];
        }
        sum++;
        if(b[1] ==1) {
            printf("经%d次洗牌回到初始状态\n",sum);
            break;
        }
    }
    return 0;
}


```

**判断密码强度等级**

```c
#include "stdio.h"
#include "string.h"
int main(void){
    char pw[20],p1=0,p2=0,p3=0,p4=0; //p1小写字母p2大写字母p3数字p4其他字符
    int n,i;
    scanf("%d",&n);
    getchar();
    while(n>0){
        p1 = p2 = p3 = p4 = 0;
        n--;
        gets(pw);
        
        if(strlen(pw)<6) {
            printf("Not Safe\n");
            continue;
        }
        for(i = 0;i<strlen(pw);i++){
            if(pw[i]>='a'&&pw[i]<='z') {
                p1++;
                continue;
            }
            if(pw[i]>='A'&&pw[i]<='Z') {
                p2++;
                continue;
            }
            if(pw[i]>='0'&&pw[i]<='9') {
                p3++;
                continue;
            }
            else p4++;
        }
        if(p1>0) p1 = 1;
        if(p2>0) p2 = 1;
        if(p3>0) p3 = 1;
        if(p4>0) p4 = 1;
//        printf("%d %d %d %d\n",p1,p2,p3,p4);
        if((p1+p2+p3+p4)==1) printf("Not Safe\n");
        if((p1+p2+p3+p4)==2) printf("Medium Safe\n");
        if((p1+p2+p3+p4)>=3) printf("Safe\n");
        
    }
    return 0;
}


```

**孪生素数**

```c
#include "stdio.h"

int ifprime(int x);
int main(void){
    int m,n,i;
    scanf("%d %d",&m,&n);
    for(i = m;i<=n;i++){
        if(ifprime(i)&&ifprime(i+2)&&(i+2)<=n){
            printf("%d %d",i,i+2);
            printf("\n");
            
        }
    }
    
    return 0;
}

int ifprime(int x){
    int i;
    if(x==1) return 0;
    for(i = 2;i<=x/2;i++){
        if(x%i==0) return 0;
    }
    return 1;
}

```
**字符串逆序**

```c
#include "stdio.h"
#include "string.h"
int main(){
    int i=0;   //abcdf
    char s[100],temp;
    gets(s);
    for(i = 0;i<strlen(s)/2;i++){
        temp = s[i];
        s[i] = s[strlen(s)-i-1];
        s[strlen(s)-i-1] = temp;
    }
    puts(s);
    return 0;
}

```

**找出元音**

```c
#include "stdio.h"
#include "string.h"
int main(){
    char s1[1000],s2[100];
    int i,j=0;
    gets(s1);
    for(i = 0;s1[i]!='\0';i++){
        if(s1[i]=='a'||s1[i]=='e'||s1[i]=='i'||s1[i]=='o'||s1[i] =='u'){
            s2[j] = s1[i];
            j++;
        }
    }
    s2[j] = '\0';
    puts(s2);
    return 0;
}

```


**寻找最长单词**

```c
#include "stdio.h"
#include "string.h"
int main(){
    char str[1000],s[100],temp[100];
    int length=0,i,j = 0;
    gets(str);
    for(i = 0;i<=strlen(str);i++){
        if(str[i] == ' '||str[i]=='\0') {
            s[j]='\0';
            if(length==0){
                length = (int)strlen(s);
                strcpy(temp, s);
                j = 0;
                continue;
            }
            if(strlen(s)>length) strcpy(temp, s);
            j = 0;
            continue;
        }
        s[j] = str[i];
        j++;
        
    }
    puts(temp);
    return 0;
}

```

**约瑟夫问题**

```c
#include <stdio.h>
 
int Josephus(int n, int m) {
    int i, x = 0;
    for (i = 1; i <= n; ++i) {
        x = (x + m) % i;
    }
    return x;
}
 
int main() {
 
    int n, m, s;
 
    scanf("%d%d%d", &n, &s, &m);
 
    printf("%d\n", Josephus(n, m) + s);
    return 0;
}
```


**绝对素数问题，该数以及该数的逆序都为素数**

```c
#include<stdio.h>
#include<string.h>
int prime(int x);
int reverse(int x);

int main(){
    int m,n,num,sum=0;
    scanf("%d %d",&m,&n);
    for(num = m;num<=n;num++){
        if(prime(num)&&prime(reverse(num))) {
            printf("%5d",num);
            sum++;
            if(sum%10==0) printf("\n");
        }
        
    }
    printf("\n");

    return 0;
}

int prime(int x){
    int i;
    for(i = 2;i<=x/2;i++){
        if(x%i == 0)  return 0;
    }
    return 1;
}

int reverse(int x){    //123
    int a;
    a = x%10;
    while(x>=10){
        x/=10;
        a= a*10+x%10;
    }
    return a;
}
```

**矩阵操作，将每一位除以该行的对角线元素**

```c
#include<stdio.h>
#include<string.h>
int main(){
    int i,j,n,m;
    float a[6][6];
    scanf("%d",&n);
    for(i = 0;i<n;i++){
        for(j = 0;j<n;j++){
            scanf("%f",&a[i][j]);
        }
    }
    for(i = 0;i<n;i++){
        m=a[i][i];
        for(j = 0;j<n;j++){
            a[i][j] = a[i][j]/m;
        }
    }
    for(i = 0;i<n;i++){
        for(j = 0;j<n;j++){
            printf("%.2f",a[i][j]);
            if(j!=(n-1)) printf(" ");
        }
        printf("\n");
    }
    return 0;
}

```

**链表解决约瑟夫问题**

```c
#include <stdio.h>
#include <stdlib.h>

/*构建结构体*/
typedef struct Node{
    int Num;
    struct Node *next;
}JoseNode, *PNode, *HNode;

/**********初始化循环单链表*********/
int JoseInit(HNode *h)
{
    if (!h)
    {
        printf("初始化链表错误！\n");
        return 0;
    }
    (*h)->next = (*h);//循环单链表
    return 1;
    
}

/*************单链表插入操作**********/
int JoseInsert(JoseNode *h, int pos, int x)
{
    PNode p=h,q;
    int i=1;
    if (pos == 1)/*尾插法*/
    {
        p->Num = x;
        p->next = p;
        return 1;
    }
    while(i<pos-1)
    {
        p=p->next;
        i++;
    }
    q=(PNode)malloc(sizeof(JoseNode));
    q->Num=x;
    q->next=p->next;
    p->next=q;
    return 1;
}

/*遍历*/
void TraverseList(HNode h, int M)
{
    int i = 0;
    PNode p = h;
    printf("参与的人的编号为：\n");
    while (i<M)
    {
        printf("%d\t", p->Num);
        p = p->next;
        i++;
    }
    printf("\n");
}
/**************出局函数****************/

int JoseDelete(HNode h, int M, int k)
{    int i;
    PNode p=h,q;
    while(M>1)
    {
        for(i=1;i<k-1;i++)
        {
            p=p->next;
        }
        
        q=p->next;
        p->next=q->next;
        printf("出局的人为：%d号\n",q->Num);
        free(q);
        
        p=p->next;
        M--;
    }
    printf("***************获胜者为：%d号***************",p->Num);
    return 1;
}


/***************************************/
int main()
{
    int i;//计数器
    int N;//参与的人数
    int k;//报数密码
    printf("请输入参与人数：");
    scanf("%d",&N);
    printf("请输入出局密码：");
    scanf("%d",&k);
    
    /**************得到头结点****************/
    HNode h = ((HNode)malloc(sizeof(JoseNode)));
    
    /***************初始化单链表************/
    JoseInit(&h);
    
    /******将编号插入到循环单链表中******/
    for (i = 1; i <=N; i++)
    {
        JoseInsert(h, i, i);
    }
    /**************遍历单链表***************/
    TraverseList(h,N);
    
    /***************出局函数************/
    if(k > 1)
        JoseDelete(h, N, k);
    else
    {
        for(i = 1; i < N; i++)
            printf("出局的人为：%d号\n",i);
        printf("***************获胜者为：%d号***************",N);
    }
    
    printf("\n");
    printf("\n");
    return 0;
}

```

**给一组数据排序，负数在左，正数在右**

```c
#include "stdio.h"
#include "string.h"
int main(){
    int a[100],b[100],i,j,n;
    while(scanf("%d",&n)!=EOF){
        j = 0;
        for(i = 0;i<n;i++){
            scanf("%d",&a[i]);
        }
        for(i = 0;i<n;i++){
            if(a[i]<=0) {
                printf("%d ",a[i]);
            }
            else{
                b[j] = a[i];
                j++;
            }
        }
        if(j==0) printf(" ");
        for(i = 0;i<j;i++){
            printf("%d",b[i]);
            if(i!=j-1) printf(" ");
        }
        printf("\n");
    }
    return 0;
}

#include<stdio.h>
#include<string.h>
int main(){
    int a[100],n,i,j,m,temp;
    scanf("%d",&n);
    for(i = 0;i<n;i++){
        scanf("%d",&a[i]);
    }
    for(i = 0;i<n;i++){  //-1 -2 2 4 -3     -1
        if(a[i]<0){        // 3  3
            if(i==0) continue;
            temp = a[i];
            for(m = 0;m<i;m++){
                if(a[m]>0){
                    break;
                }
            }
            if(m ==i) continue;
            for(j=i;j>m;j--){
                a[j] = a[j-1];
            }
            a[m] = temp;
        }
    }
    for(i = 0;i<n;i++){
        printf("%d",a[i]);
        if(i!=n-1) printf(" ");
    }
    printf("\n");
    return 0;
}

```


**递归求组合函数**

```c
#include<stdio.h>
#include<string.h>
int zh(int m,int n);
int main(){
    int m,n;
    scanf("%d %d",&m,&n);
    printf("%d\n",zh(m,n));
    return 0;
}

int zh(int m,int n){
    int sum=0;
    if(m<n) return 0;
    if(n == 0) {
        sum = 1;
        return sum;
    }
    if(n == 1) {
        sum +=m;
        return sum;
    }
    else{
        sum +=zh(m-1, n-1)+zh(m-1,n);
    }
    return sum;
}

```


**输入一个长度不超过 100 的字符串，删除串中的重复字符。**

```c
#include<stdio.h>
#include<string.h>
int main() {
    char str[100],str2[100];
    int i,j=0,m,flag;
    gets(str);
    for(i = 0;i<strlen(str);i++){
        if(j==0) {
            str2[j] = str[i];
            j++;
        }
        else{
            flag=1;
            for(m=0;m<=j;m++){
                if(str[i]==str2[m]) {
                    flag=0;
                    break;
                }
            }
            if(flag) {
                str2[j] = str[i];
                j++;
            }
        }
    }
    str2[j]='\0';
    puts(str2);
    return 0;
}
```







**输入数据有多组。每组输入的第一行是一个整数 n（0 < n <= 1000），表示接下来会有 n 个文件名。接下来的 n行为文件名，每个文件名占一行。文件名最多 16 个字符，并且中间不包含空格。如果 n 等于 0，则程序结束。输出以字典顺序输出每一组数据中的病毒文件名。每个文件名输出一行。**

```c
#include<stdio.h>
#include<string.h>
int isVirus(char *s)
{
    int len;
    len=(int)strlen(s);
    if(len>4 && strcmp(s+len-4,".exe") == 0) {return 1;}
    return 0;
}
int main()
{
    int n,i,j,k,l,m,flag;
    char s[1000][17],str[1000][17],temp[17];
    char *p,*q;
    scanf("%d",&n);
    while(n!=0)
    {
        j=0;
        for(i=0;i<n;i++) {scanf("%s",s[i]);}
        for(i=0;i<n;i++)
        {
            if(isVirus(s[i]))
            {
                for(k=0;k<n;k++)
                {
                    if(k==i) {continue;}
                    else
                    {
                        if((strlen(s[i])-strlen(s[k]))==4)
                        {
                            p=s[k];q=s[i];
                            flag=1;
                            while(*p!='\0' && *q!='\0')
                            {
                                if(*p==*q) {p++;q++;}
                                else {flag=0;break;}
                            }
                            if(flag) {strcpy(str[j],s[i]);j++;}
                        }
                    }
                }
            }
        }
        for(i=0;i<j;i++)
        {
            for(l=i+1;l<j;l++)
            {
                if(strcmp(str[i],str[l])>0)
                {
                    strcpy(temp,str[l]);
                    strcpy(str[l],str[i]);
                    strcpy(str[i],temp);
                }
            }
        }
        for(i=0;i<j;i++) {puts(str[i]);}
        scanf("%d",&n);
    }
    return 0;
}




```

```c
#include<stdio.h>
#include<string.h>
int main()
{
    char s1[100], s2[100],s3[50];
    int i, j, k1, k2, max=0, w1[100],w2[100],f;
    while((gets(s1)!= NULL)&&(gets(s2)!=NULL)){
        i = j = k1 = k2 = max=f=0;
        s3[0] = '\0';
        for(i=0, k1=0, f=1 ; s1[i]!='\0'; i++)
        {
            if(s1[i]==' ')  { s1[i]='\0'; f=1;}
            if(f==1&&s1[i]!='\0') { w1[k1]=i;k1++; f=0;}
        }
        for(i=0, k2=0, f=1;  s2[i]!='\0'; i++)
        {
            if(s2[i]==' ')   { s2[i]='\0';  f=1;}
            if(f==1&&s2[i]!='\0') {w2[k2]=i; k2++; f=0;}
        }
        for(i=0; i<k1; i++)
            for(j=0; j<k2; j++)
                if(strcmp(s1+w1[i],s2+w2[j])==0)
                    if(strlen(s1+w1[i])>=max)
                    {max = (int)strlen(s1+w1[i]); strcpy(s3, s1+w1[i]);}
        if(max!=0) puts(s3);
        else printf("No common word!\n");
    }
    

}
```
**寻找最长公共单词**

```c
错误代码
#include "stdio.h"
#include "string.h"

int main(){
    char str1[100], str2[100],s1[20],length=0,s2[20],result[20];
    int i,j=0,k=0;
    fgets(str1, 100, stdin);
    fgets(str2, 100, stdin);
    for(i = 0;i<strlen(str1)-1;i++){
        if(str1[i]!='?'&&str1[i]!=','&&str1[i]!='.') {
            s1[j] = str1[i];
            j++;
        }
        else{
            s1[j]='\0';
            puts(s1);
            for(j = 0;j<strlen(str2)-1;j++){
                if(!(str2[i]=='?'||str2[i]==','||str2[i]=='.')) {
                    s2[k] = str2[j];
                    k++;
                }
                else{
                    s2[k]='\0';
                    //                    puts(str2);
                    if(strcmp(s1, s2)==0&&strlen(s1)>length) {
                        length=strlen(s1);
                        strcpy(result, s2);
                    }
                    k=0;
                }
            }
            j=0;
            
        }
    }
    if(length!=0) printf("%s\n",result);
    else printf("No common word!\n");
    return 0;
}
```










```c
#include "stdio.h"
#include "string.h"
int main(){
    char str1[50][20];
    char str2[50][20];
    int stus, comes,i,j=0;
    while(scanf("%d %d",&stus,&comes)!=EOF){
        j=0;
        for(i=0;i<stus;i++){
            scanf("%s",str1[i]);
        }
        for(i = 0;i<comes;i++){
            scanf("%s",str2[i]);
        }
        for(i=0;i<stus;i++){
            if(strcmp(str1[i], str2[j])==0){
                printf("Yes\n");
                j++;
            }
            else{
                printf("No\n");
            }
        }
    }
    return 0;
}
```








```c
#include<stdio.h>
int main(){
    int a,b,c,d,e,f;//a-f对应1*1到6*6的箱子
    int u[]={0,5,3,1};//装3*3类箱子不满时可以装2*2类箱子的4种情形
    while(scanf("%d%d%d%d%d%d", &a, &b, &c, &d, &e, &f)!=EOF){
        if(a==0 && b==0 && c==0 && d==0 && e==0 && f==0)break;
        int x,y;//x代表用于装2*2类箱子的空位，y代表用于装1类箱子的空位
        int N=0;//总共所需要的包装的数量
        N=f+e+d+(c+3)/4;//统计3*3-6*6类箱子所需要的包装数
        //上式中（c+3)/4的作用：当c/4的余数不论为几时，都需要再增加一个箱子，即只能多不能少；
        x=5*d+u[c%4];//统计4类箱子和3类箱子留给2类箱子的空位
        if(b >x){
            N+=(b-x+8)/9;//统计算上遗留空位2*2类箱子所占的包装数量
        }
        y=N*36-f*36-e*25-d*16-c*9-b*4;//遗留给1*1类箱子的空位
        if(a >y){
            N+=(a-y+35)/36;
        }
        printf("%d\n", N);
    }
    return 0;
}
#include "stdio.h"
int main(void){
    char str[100], ch;
    int i=0;
    scanf("%s",str);
    getchar();
    scanf("%c",&ch);
    while(str[i] != '\0'){
        if(str[i] == ch) {
            i++;
            continue;
        }
        printf("%c",str[i]);
        i++;
    }
    printf("\n");
    return 0;
}
```

```c
#include<stdio.h>
#include<string.h>
int main()
{
    char s1[100], s2[100],s3[50];
    int i, j, k1, k2, max=0, w1[100],w2[100],f;
    gets(s1);  gets(s2);
    for(i=0, k1=0, f=1 ; s1[i]!='\0'; i++)
    {
        if(s1[i]==' ')  { s1[i]='\0'; f=1;}
        if(f==1&&s1[i]!='\0') { w1[k1]=i;k1++; f=0;}
    }
    for(i=0, k2=0, f=1;  s2[i]!='\0'; i++)
    {
        if(s2[i]==' ')   { s2[i]='\0';  f=1;}
        if(f==1&&s2[i]!='\0') {w2[k2]=i; k2++; f=0;}
    }
    for(i=0; i<k1; i++)
        for(j=0; j<k2; j++)
            if(strcmp(s1+w1[i],s2+w2[j])==0)
                if(strlen(s1+w1[i])>=max)
                {max = (int)strlen(s1+w1[i]); strcpy(s3, s1+w1[i]);}
    puts(s3);
    return 0;
}
```


